// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as HashSet from "../src/HashSet.mjs";
import * as Js_math from "@rescript/std/lib/es6/js_math.js";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Belt_SetInt from "@rescript/std/lib/es6/belt_SetInt.js";

function intHasher(x) {
  return x;
}

var actions = Belt_Array.makeBy(3000000, (function (i) {
        var x = Js_math.random_int(0, 1500000);
        var match = Js_math.random_int(0, 2);
        if (match !== 0) {
          return {
                  TAG: /* Remove */1,
                  _0: x
                };
        } else {
          return {
                  TAG: /* Insert */0,
                  _0: x
                };
        }
      }));

var init_0 = HashSet.make(intHasher);

var init = [
  init_0,
  undefined
];

function printElapsed(title, f) {
  var start = Date.now();
  Curry._1(f, undefined);
  var end = Date.now();
  console.log("[" + title + "] elapsed: " + (end - start).toString());
  
}

printElapsed("HashSet", (function (param) {
        return Belt_Array.reduce(actions, init_0, (function (s2, action) {
                      if (action.TAG === /* Insert */0) {
                        return HashSet.set(s2, action._0);
                      } else {
                        return HashSet.remove(s2, action._0);
                      }
                    }));
      }));

printElapsed("BeltSet", (function (param) {
        return Belt_Array.reduce(actions, undefined, (function (s2, action) {
                      if (action.TAG === /* Insert */0) {
                        return Belt_SetInt.add(s2, action._0);
                      } else {
                        return Belt_SetInt.remove(s2, action._0);
                      }
                    }));
      }));

printElapsed("HashSet", (function (param) {
        return Belt_Array.reduce(actions, init_0, (function (s2, action) {
                      if (action.TAG === /* Insert */0) {
                        return HashSet.set(s2, action._0);
                      } else {
                        return HashSet.remove(s2, action._0);
                      }
                    }));
      }));

printElapsed("BeltSet", (function (param) {
        return Belt_Array.reduce(actions, undefined, (function (s2, action) {
                      if (action.TAG === /* Insert */0) {
                        return Belt_SetInt.add(s2, action._0);
                      } else {
                        return Belt_SetInt.remove(s2, action._0);
                      }
                    }));
      }));

printElapsed("HashSet", (function (param) {
        return Belt_Array.reduce(actions, init_0, (function (s2, action) {
                      if (action.TAG === /* Insert */0) {
                        return HashSet.set(s2, action._0);
                      } else {
                        return HashSet.remove(s2, action._0);
                      }
                    }));
      }));

printElapsed("BeltSet", (function (param) {
        return Belt_Array.reduce(actions, undefined, (function (s2, action) {
                      if (action.TAG === /* Insert */0) {
                        return Belt_SetInt.add(s2, action._0);
                      } else {
                        return Belt_SetInt.remove(s2, action._0);
                      }
                    }));
      }));

var n = 3000000;

var BeltSet;

export {
  intHasher ,
  n ,
  actions ,
  BeltSet ,
  init ,
  printElapsed ,
  
}
/* actions Not a pure module */
